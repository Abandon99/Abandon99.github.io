<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>终极二分法</title>
    <url>/2023/02/13/binary/</url>
    <content><![CDATA[<!-- 
## 二分法适用：
- 有序数组
- 找值

先看 leetcode 35题：


给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。

请必须使用时间复杂度为 O(log n) 的算法。

示例 1:

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: nums = [1,3,5,6], target = 5</span><br><span class="line">输出: 2</span><br></pre></td></tr></table></figure>

<p>我的新写法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var searchInsert = function(nums, target) &#123;</span><br><span class="line">    if(nums[0] &gt; target) return 0</span><br><span class="line">    if(nums[nums.length - 1] &lt; target) return nums.length</span><br><span class="line"></span><br><span class="line">    let left = -1, right = nums.length;</span><br><span class="line"></span><br><span class="line">    while(left + 1 !== right) &#123;</span><br><span class="line">        let mid = left + ~~((right - left) / 2)</span><br><span class="line"></span><br><span class="line">        if(nums[mid] &lt; target) &#123;</span><br><span class="line">            left = mid</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            right = mid</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return right</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>leetcode 407 比较简单</p>
<p>给定一个 n 个元素有序的（升序）整型数组 nums 和一个目标值 target  ，写一个函数搜索 nums 中的 target，如果目标值存在返回下标，否则返回 -1。</p>
<p>例子1</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: nums = [-1,0,3,5,9,12], target = 9</span><br><span class="line">输出: 4</span><br><span class="line">解释: 9 出现在 nums 中并且下标为 4</span><br></pre></td></tr></table></figure>

<p>新写法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function search(nums, target) &#123;</span><br><span class="line"></span><br><span class="line">    let left = -1, right = nums.length;</span><br><span class="line"></span><br><span class="line">    while(left + 1 !== right) &#123;</span><br><span class="line">        let mid = left + ~~((right - left) / 2)</span><br><span class="line"></span><br><span class="line">        if(nums[mid] &lt; target) &#123;</span><br><span class="line">            left = mid</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            right = mid</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if(nums[left] === target) return left</span><br><span class="line">    if(nums[right] === target) return right</span><br><span class="line">    return -1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>leetcode 278</p>
<p>第一个错误的版本</p>
<p>你是产品经理，目前正在带领一个团队开发新的产品。不幸的是，你的产品的最新版本没有通过质量检测。由于每个版本都是基于之前的版本开发的，所以错误的版本之后的所有版本都是错的。</p>
<p>假设你有 n 个版本 [1, 2, …, n]，你想找出导致之后所有版本出错的第一个错误的版本。</p>
<p>你可以通过调用 bool isBadVersion(version) 接口来判断版本号 version 是否在单元测试中出错。实现一个函数来查找第一个错误的版本。你应该尽量减少对调用 API 的次数。</p>
<p>实例1</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：n = 5, bad = 4</span><br><span class="line">输出：4</span><br><span class="line">解释：</span><br><span class="line">调用 isBadVersion(3) -&gt; false </span><br><span class="line">调用 isBadVersion(5) -&gt; true </span><br><span class="line">调用 isBadVersion(4) -&gt; true</span><br><span class="line">所以，4 是第一个错误的版本</span><br></pre></td></tr></table></figure>

<p>```<br>var solution = function(isBadVersion) {<br>    return function(n) {<br>        let left = 0, right = n + 1;</p>
<pre><code>    while (left + 1 !== right) &#123;
        const mid = left + ~~((right - left) / 2)
        if(isBadVersion(mid)) &#123;
            right = mid
        &#125; else &#123;
            left = mid
        &#125;
    &#125;
    return right
&#125;;
</code></pre>
<p>};<br>``` –&gt;</p>
]]></content>
      <categories>
        <category>coding</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>二分法</tag>
      </tags>
  </entry>
  <entry>
    <title>明明1句话就能理解「闭包」</title>
    <url>/2017/12/28/closer/</url>
    <content><![CDATA[<!-- 
## 讲人话:

**「 一个函数 + 这个函数的外部环境   =   闭包 」**

所以，这类看似不负责的说法都是正确的：

> 一个函数就是一个闭包

> A clouser is nothing but a function with scope.

> A Closure is nothing but a function inside a function.

我感觉闭包已经讲完了，但是这样你们肯定想揍我。

## 讲专业:

### 先瞅瞅wiki
> In programming languages, a closure, also lexical closure or function closure, is a technique for implementing lexically scoped name binding in a language with first-class functions. Operationally, a closure is a record storing a function together with an environment. The environment is a mapping associating each free variable of the function (variables that are used locally, but defined in an enclosing scope) with the value or reference to which the name was bound when the closure was created. Unlike a plain function, a closure allows the function to access those captured variables through the closure's copies of their values or references, even when the function is invoked outside their scope.

大概意思是：闭包（也称为词汇闭包或函数闭包）是一种在具有一级函数的语言中实现词汇范围名称绑定的技术。从操作上讲，闭包是一个记录，它将一个函数与一个环境一起存储。 环境是一种映射，将函数的每个自由变量（本地使用但在封闭范围内定义的变量）与创建闭包时名称绑定到的值或引用相关联。 与普通函数不同，闭包允许函数通过闭包的值或引用副本访问这些捕获的变量，即使函数在其作用域之外被调用。

### 再瞅瞅MDN对JavaScript中闭包的描述
> 一个函数和对其周围状态（lexical environment，词法环境）的引用捆绑在一起（或者说函数被引用包围），这样的组合就是闭包（closure）。也就是说，闭包让你可以在一个内层函数中访问到其外层函数的作用域。在 JavaScript 中，每当创建一个函数，闭包就会在函数创建的同时被创建出来。

### 我来总结：

我觉得MDN说的好。 -->


]]></content>
      <categories>
        <category>coding</category>
        <category>frontEnd</category>
      </categories>
      <tags>
        <tag>闭包</tag>
        <tag>函数</tag>
      </tags>
  </entry>
  <entry>
    <title>我读《悉达多》</title>
    <url>/2023/02/13/xidaduo/</url>
    <content><![CDATA[<!-- 
## 曾找过”自我“吗

看过一个对自我比较有意思且精辟的描述，自我是找不到的，你去撞墙，弹回来了，你就找到了自我。

悉达多的寻找自我之路，似乎有异曲同工之妙。 -->
]]></content>
      <tags>
        <tag>读书</tag>
        <tag>哲学</tag>
      </tags>
  </entry>
</search>

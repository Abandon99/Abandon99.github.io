(window.webpackJsonp=window.webpackJsonp||[]).push([[11],{573:function(t,n,e){"use strict";e.r(n);var s=e(13),a=Object(s.a)({},(function(){var t=this,n=t.$createElement,e=t._self._c||n;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h1",{attrs:{id:"二分法适用"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#二分法适用"}},[t._v("#")]),t._v(" 二分法适用：")]),t._v(" "),e("ul",[e("li",[t._v("有序数组")]),t._v(" "),e("li",[t._v("找值")])]),t._v(" "),e("p",[t._v("先看 leetcode 35题：")]),t._v(" "),e("p",[t._v("给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。")]),t._v(" "),e("p",[t._v("请必须使用时间复杂度为 O(log n) 的算法。")]),t._v(" "),e("p",[t._v("示例 1:")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("输入: nums = [1,3,5,6], target = 5\n输出: 2\n")])])]),e("p",[t._v("我的新写法")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("var searchInsert = function(nums, target) {\n    if(nums[0] > target) return 0\n    if(nums[nums.length - 1] < target) return nums.length\n\n    let left = -1, right = nums.length;\n\n    while(left + 1 !== right) {\n        let mid = left + ~~((right - left) / 2)\n\n        if(nums[mid] < target) {\n            left = mid\n        } else {\n            right = mid\n        }\n    }\n\n    return right\n\n}\n")])])]),e("p",[t._v("leetcode 407 比较简单")]),t._v(" "),e("p",[t._v("给定一个 n 个元素有序的（升序）整型数组 nums 和一个目标值 target  ，写一个函数搜索 nums 中的 target，如果目标值存在返回下标，否则返回 -1。")]),t._v(" "),e("p",[t._v("例子1")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("输入: nums = [-1,0,3,5,9,12], target = 9\n输出: 4\n解释: 9 出现在 nums 中并且下标为 4\n")])])]),e("p",[t._v("新写法")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("function search(nums, target) {\n\n    let left = -1, right = nums.length;\n\n    while(left + 1 !== right) {\n        let mid = left + ~~((right - left) / 2)\n\n        if(nums[mid] < target) {\n            left = mid\n        } else {\n            right = mid\n        }\n    }\n\n    if(nums[left] === target) return left\n    if(nums[right] === target) return right\n    return -1\n}\n")])])]),e("p",[t._v("leetcode 278")]),t._v(" "),e("p",[t._v("第一个错误的版本")]),t._v(" "),e("p",[t._v("你是产品经理，目前正在带领一个团队开发新的产品。不幸的是，你的产品的最新版本没有通过质量检测。由于每个版本都是基于之前的版本开发的，所以错误的版本之后的所有版本都是错的。")]),t._v(" "),e("p",[t._v("假设你有 n 个版本 [1, 2, ..., n]，你想找出导致之后所有版本出错的第一个错误的版本。")]),t._v(" "),e("p",[t._v("你可以通过调用 bool isBadVersion(version) 接口来判断版本号 version 是否在单元测试中出错。实现一个函数来查找第一个错误的版本。你应该尽量减少对调用 API 的次数。")]),t._v(" "),e("p",[t._v("实例1")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("输入：n = 5, bad = 4\n输出：4\n解释：\n调用 isBadVersion(3) -> false \n调用 isBadVersion(5) -> true \n调用 isBadVersion(4) -> true\n所以，4 是第一个错误的版本\n")])])]),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("var solution = function(isBadVersion) {\n    return function(n) {\n        let left = 0, right = n + 1;\n\n        while (left + 1 !== right) {\n            const mid = left + ~~((right - left) / 2)\n            if(isBadVersion(mid)) {\n                right = mid\n            } else {\n                left = mid\n            }\n        }\n        return right\n    };\n};\n")])])])])}),[],!1,null,null,null);n.default=a.exports}}]);